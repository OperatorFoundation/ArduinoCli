// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cc/arduino/cli/commands/v1/commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// This file is part of arduino-cli.
//
// Copyright 2020 ARDUINO SA (http://www.arduino.cc/)
//
// This software is released under the GNU General Public License version 3,
// which covers the main part of arduino-cli.
// The terms of this license can be found at:
// https://www.gnu.org/licenses/gpl-3.0.en.html
//
// You can be released from the requirements of the above licenses by purchasing
// a commercial license. Buying such a license is mandatory if you want to
// modify or otherwise use the software for commercial activities involving the
// Arduino software without disclosing the source code of your own applications.
// To purchase a commercial license, send an email to license@arduino.cc.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Cc_Arduino_Cli_Commands_V1_CreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_CreateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Arduino Core instance.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_InitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Arduino Core instance.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// Profile to use
  public var profile: String = String()

  /// The path where the sketch is stored
  public var sketchPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_InitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Cc_Arduino_Cli_Commands_V1_InitResponse.OneOf_Message? = nil

  public var initProgress: Cc_Arduino_Cli_Commands_V1_InitResponse.Progress {
    get {
      if case .initProgress(let v)? = message {return v}
      return Cc_Arduino_Cli_Commands_V1_InitResponse.Progress()
    }
    set {message = .initProgress(newValue)}
  }

  public var error: Google_Rpc_Status {
    get {
      if case .error(let v)? = message {return v}
      return Google_Rpc_Status()
    }
    set {message = .error(newValue)}
  }

  /// Selected profile information
  public var profile: Cc_Arduino_Cli_Commands_V1_Profile {
    get {
      if case .profile(let v)? = message {return v}
      return Cc_Arduino_Cli_Commands_V1_Profile()
    }
    set {message = .profile(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Message: Equatable {
    case initProgress(Cc_Arduino_Cli_Commands_V1_InitResponse.Progress)
    case error(Google_Rpc_Status)
    /// Selected profile information
    case profile(Cc_Arduino_Cli_Commands_V1_Profile)

  #if !swift(>=4.1)
    public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_InitResponse.OneOf_Message, rhs: Cc_Arduino_Cli_Commands_V1_InitResponse.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initProgress, .initProgress): return {
        guard case .initProgress(let l) = lhs, case .initProgress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profile, .profile): return {
        guard case .profile(let l) = lhs, case .profile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Progress {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Progress of the downloads of platforms and libraries index files.
    public var downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress {
      get {return _downloadProgress ?? Cc_Arduino_Cli_Commands_V1_DownloadProgress()}
      set {_downloadProgress = newValue}
    }
    /// Returns true if `downloadProgress` has been explicitly set.
    public var hasDownloadProgress: Bool {return self._downloadProgress != nil}
    /// Clears the value of `downloadProgress`. Subsequent reads from it will return its default value.
    public mutating func clearDownloadProgress() {self._downloadProgress = nil}

    /// Describes the current stage of the initialization.
    public var taskProgress: Cc_Arduino_Cli_Commands_V1_TaskProgress {
      get {return _taskProgress ?? Cc_Arduino_Cli_Commands_V1_TaskProgress()}
      set {_taskProgress = newValue}
    }
    /// Returns true if `taskProgress` has been explicitly set.
    public var hasTaskProgress: Bool {return self._taskProgress != nil}
    /// Clears the value of `taskProgress`. Subsequent reads from it will return its default value.
    public mutating func clearTaskProgress() {self._taskProgress = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress? = nil
    fileprivate var _taskProgress: Cc_Arduino_Cli_Commands_V1_TaskProgress? = nil
  }

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_DestroyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Arduino Core Service instance to destroy.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_DestroyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateIndexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Progress of the platforms index download.
  public var downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress {
    get {return _downloadProgress ?? Cc_Arduino_Cli_Commands_V1_DownloadProgress()}
    set {_downloadProgress = newValue}
  }
  /// Returns true if `downloadProgress` has been explicitly set.
  public var hasDownloadProgress: Bool {return self._downloadProgress != nil}
  /// Clears the value of `downloadProgress`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadProgress() {self._downloadProgress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Progress of the libraries index download.
  public var downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress {
    get {return _downloadProgress ?? Cc_Arduino_Cli_Commands_V1_DownloadProgress()}
    set {_downloadProgress = newValue}
  }
  /// Returns true if `downloadProgress` has been explicitly set.
  public var hasDownloadProgress: Bool {return self._downloadProgress != nil}
  /// Clears the value of `downloadProgress`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadProgress() {self._downloadProgress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Progress of the index download.
  public var downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress {
    get {return _downloadProgress ?? Cc_Arduino_Cli_Commands_V1_DownloadProgress()}
    set {_downloadProgress = newValue}
  }
  /// Returns true if `downloadProgress` has been explicitly set.
  public var hasDownloadProgress: Bool {return self._downloadProgress != nil}
  /// Clears the value of `downloadProgress`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadProgress() {self._downloadProgress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _downloadProgress: Cc_Arduino_Cli_Commands_V1_DownloadProgress? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_OutdatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_OutdatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of installed libraries that can be updated.
  public var outdatedLibraries: [Cc_Arduino_Cli_Commands_V1_InstalledLibrary] = []

  /// List of installed cores that can be updated.
  public var outdatedPlatforms: [Cc_Arduino_Cli_Commands_V1_Platform] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_UpgradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// Set to true to not run (eventual) post install scripts
  public var skipPostInstall: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_UpgradeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Progress of the downloads of the platforms and libraries files.
  public var progress: Cc_Arduino_Cli_Commands_V1_DownloadProgress {
    get {return _progress ?? Cc_Arduino_Cli_Commands_V1_DownloadProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  /// Description of the current stage of the upgrade.
  public var taskProgress: Cc_Arduino_Cli_Commands_V1_TaskProgress {
    get {return _taskProgress ?? Cc_Arduino_Cli_Commands_V1_TaskProgress()}
    set {_taskProgress = newValue}
  }
  /// Returns true if `taskProgress` has been explicitly set.
  public var hasTaskProgress: Bool {return self._taskProgress != nil}
  /// Clears the value of `taskProgress`. Subsequent reads from it will return its default value.
  public mutating func clearTaskProgress() {self._taskProgress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _progress: Cc_Arduino_Cli_Commands_V1_DownloadProgress? = nil
  fileprivate var _taskProgress: Cc_Arduino_Cli_Commands_V1_TaskProgress? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_VersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of Arduino CLI in use.
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_NewSketchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// New sketch name
  public var sketchName: String = String()

  /// Optional: create a Sketch in this directory
  /// (used as "Sketchbook" directory).
  /// Default Sketchbook directory "directories.User" is used if sketch_dir is
  /// empty.
  public var sketchDir: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_NewSketchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Absolute path to a main sketch file
  public var mainFile: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_LoadSketchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arduino Core Service instance from the Init response.
  public var instance: Cc_Arduino_Cli_Commands_V1_Instance {
    get {return _instance ?? Cc_Arduino_Cli_Commands_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// Absolute path to single sketch file or a sketch folder
  public var sketchPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Cc_Arduino_Cli_Commands_V1_Instance? = nil
}

public struct Cc_Arduino_Cli_Commands_V1_LoadSketchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Absolute path to a main sketch files
  public var mainFile: String = String()

  /// Absolute path to folder that contains main_file
  public var locationPath: String = String()

  /// List of absolute paths to other sketch files
  public var otherSketchFiles: [String] = []

  /// List of absolute paths to additional sketch files
  public var additionalFiles: [String] = []

  /// List of absolute paths to supported files in the sketch root folder, main
  /// file excluded
  public var rootFolderFiles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_ArchiveSketchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Absolute path to Sketch file or folder containing Sketch file
  public var sketchPath: String = String()

  /// Absolute path to archive that will be created or folder that will contain
  /// it
  public var archivePath: String = String()

  /// Specifies if build directory should be included in the archive
  public var includeBuildDir: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cc_Arduino_Cli_Commands_V1_ArchiveSketchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cc_Arduino_Cli_Commands_V1_CreateRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_CreateResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_InitRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_InitResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_InitResponse.OneOf_Message: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_InitResponse.Progress: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_DestroyRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_DestroyResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateIndexRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateIndexResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_OutdatedRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_OutdatedResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpgradeRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_UpgradeResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_VersionRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_VersionResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_NewSketchRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_NewSketchResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_LoadSketchRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_LoadSketchResponse: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_ArchiveSketchRequest: @unchecked Sendable {}
extension Cc_Arduino_Cli_Commands_V1_ArchiveSketchResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cc.arduino.cli.commands.v1"

extension Cc_Arduino_Cli_Commands_V1_CreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_CreateRequest, rhs: Cc_Arduino_Cli_Commands_V1_CreateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_CreateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_CreateResponse, rhs: Cc_Arduino_Cli_Commands_V1_CreateResponse) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_InitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .same(proto: "profile"),
    3: .standard(proto: "sketch_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.profile) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sketchPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.profile.isEmpty {
      try visitor.visitSingularStringField(value: self.profile, fieldNumber: 2)
    }
    if !self.sketchPath.isEmpty {
      try visitor.visitSingularStringField(value: self.sketchPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_InitRequest, rhs: Cc_Arduino_Cli_Commands_V1_InitRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.profile != rhs.profile {return false}
    if lhs.sketchPath != rhs.sketchPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_InitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "init_progress"),
    2: .same(proto: "error"),
    3: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cc_Arduino_Cli_Commands_V1_InitResponse.Progress?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .initProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .initProgress(v)
        }
      }()
      case 2: try {
        var v: Google_Rpc_Status?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .error(v)
        }
      }()
      case 3: try {
        var v: Cc_Arduino_Cli_Commands_V1_Profile?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .profile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .profile(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .initProgress?: try {
      guard case .initProgress(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .profile?: try {
      guard case .profile(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_InitResponse, rhs: Cc_Arduino_Cli_Commands_V1_InitResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_InitResponse.Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Cc_Arduino_Cli_Commands_V1_InitResponse.protoMessageName + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_progress"),
    2: .standard(proto: "task_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._downloadProgress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._downloadProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._taskProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_InitResponse.Progress, rhs: Cc_Arduino_Cli_Commands_V1_InitResponse.Progress) -> Bool {
    if lhs._downloadProgress != rhs._downloadProgress {return false}
    if lhs._taskProgress != rhs._taskProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_DestroyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestroyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_DestroyRequest, rhs: Cc_Arduino_Cli_Commands_V1_DestroyRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_DestroyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestroyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_DestroyResponse, rhs: Cc_Arduino_Cli_Commands_V1_DestroyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateIndexRequest, rhs: Cc_Arduino_Cli_Commands_V1_UpdateIndexRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateIndexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateIndexResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._downloadProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._downloadProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateIndexResponse, rhs: Cc_Arduino_Cli_Commands_V1_UpdateIndexResponse) -> Bool {
    if lhs._downloadProgress != rhs._downloadProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateLibrariesIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexRequest, rhs: Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateLibrariesIndexResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._downloadProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._downloadProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexResponse, rhs: Cc_Arduino_Cli_Commands_V1_UpdateLibrariesIndexResponse) -> Bool {
    if lhs._downloadProgress != rhs._downloadProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCoreLibrariesIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexRequest, rhs: Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCoreLibrariesIndexResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._downloadProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._downloadProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexResponse, rhs: Cc_Arduino_Cli_Commands_V1_UpdateCoreLibrariesIndexResponse) -> Bool {
    if lhs._downloadProgress != rhs._downloadProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_OutdatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutdatedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_OutdatedRequest, rhs: Cc_Arduino_Cli_Commands_V1_OutdatedRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_OutdatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutdatedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outdated_libraries"),
    2: .standard(proto: "outdated_platforms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outdatedLibraries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outdatedPlatforms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outdatedLibraries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outdatedLibraries, fieldNumber: 1)
    }
    if !self.outdatedPlatforms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outdatedPlatforms, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_OutdatedResponse, rhs: Cc_Arduino_Cli_Commands_V1_OutdatedResponse) -> Bool {
    if lhs.outdatedLibraries != rhs.outdatedLibraries {return false}
    if lhs.outdatedPlatforms != rhs.outdatedPlatforms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpgradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "skip_post_install"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.skipPostInstall) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.skipPostInstall != false {
      try visitor.visitSingularBoolField(value: self.skipPostInstall, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpgradeRequest, rhs: Cc_Arduino_Cli_Commands_V1_UpgradeRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.skipPostInstall != rhs.skipPostInstall {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_UpgradeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "progress"),
    2: .standard(proto: "task_progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskProgress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._taskProgress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_UpgradeResponse, rhs: Cc_Arduino_Cli_Commands_V1_UpgradeResponse) -> Bool {
    if lhs._progress != rhs._progress {return false}
    if lhs._taskProgress != rhs._taskProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_VersionRequest, rhs: Cc_Arduino_Cli_Commands_V1_VersionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_VersionResponse, rhs: Cc_Arduino_Cli_Commands_V1_VersionResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_NewSketchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewSketchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "sketch_name"),
    3: .standard(proto: "sketch_dir"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sketchName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sketchDir) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sketchName.isEmpty {
      try visitor.visitSingularStringField(value: self.sketchName, fieldNumber: 2)
    }
    if !self.sketchDir.isEmpty {
      try visitor.visitSingularStringField(value: self.sketchDir, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_NewSketchRequest, rhs: Cc_Arduino_Cli_Commands_V1_NewSketchRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.sketchName != rhs.sketchName {return false}
    if lhs.sketchDir != rhs.sketchDir {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_NewSketchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewSketchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "main_file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mainFile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mainFile.isEmpty {
      try visitor.visitSingularStringField(value: self.mainFile, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_NewSketchResponse, rhs: Cc_Arduino_Cli_Commands_V1_NewSketchResponse) -> Bool {
    if lhs.mainFile != rhs.mainFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_LoadSketchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadSketchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "sketch_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sketchPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sketchPath.isEmpty {
      try visitor.visitSingularStringField(value: self.sketchPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_LoadSketchRequest, rhs: Cc_Arduino_Cli_Commands_V1_LoadSketchRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs.sketchPath != rhs.sketchPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_LoadSketchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadSketchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "main_file"),
    2: .standard(proto: "location_path"),
    3: .standard(proto: "other_sketch_files"),
    4: .standard(proto: "additional_files"),
    5: .standard(proto: "root_folder_files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mainFile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.locationPath) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.otherSketchFiles) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.additionalFiles) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.rootFolderFiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mainFile.isEmpty {
      try visitor.visitSingularStringField(value: self.mainFile, fieldNumber: 1)
    }
    if !self.locationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.locationPath, fieldNumber: 2)
    }
    if !self.otherSketchFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.otherSketchFiles, fieldNumber: 3)
    }
    if !self.additionalFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalFiles, fieldNumber: 4)
    }
    if !self.rootFolderFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rootFolderFiles, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_LoadSketchResponse, rhs: Cc_Arduino_Cli_Commands_V1_LoadSketchResponse) -> Bool {
    if lhs.mainFile != rhs.mainFile {return false}
    if lhs.locationPath != rhs.locationPath {return false}
    if lhs.otherSketchFiles != rhs.otherSketchFiles {return false}
    if lhs.additionalFiles != rhs.additionalFiles {return false}
    if lhs.rootFolderFiles != rhs.rootFolderFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_ArchiveSketchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveSketchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sketch_path"),
    2: .standard(proto: "archive_path"),
    3: .standard(proto: "include_build_dir"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sketchPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.archivePath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeBuildDir) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sketchPath.isEmpty {
      try visitor.visitSingularStringField(value: self.sketchPath, fieldNumber: 1)
    }
    if !self.archivePath.isEmpty {
      try visitor.visitSingularStringField(value: self.archivePath, fieldNumber: 2)
    }
    if self.includeBuildDir != false {
      try visitor.visitSingularBoolField(value: self.includeBuildDir, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_ArchiveSketchRequest, rhs: Cc_Arduino_Cli_Commands_V1_ArchiveSketchRequest) -> Bool {
    if lhs.sketchPath != rhs.sketchPath {return false}
    if lhs.archivePath != rhs.archivePath {return false}
    if lhs.includeBuildDir != rhs.includeBuildDir {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cc_Arduino_Cli_Commands_V1_ArchiveSketchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveSketchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cc_Arduino_Cli_Commands_V1_ArchiveSketchResponse, rhs: Cc_Arduino_Cli_Commands_V1_ArchiveSketchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
